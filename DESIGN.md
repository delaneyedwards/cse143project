In programming Outlaws, we had to start off with the basic structure of a game program, so we imported pygame and created a simple game window that accepts keyboard input.

Throughout the program, we have several saved variables, like the width, height, some colors, pictures and more that we chose to save as variables in order make our code more clear.

At the beginning we were using enemies as similar entities to the player, but as we progressed we discovered that it was not as efficient as using pygame Sprites since there would be many enemies and they each had their own bullets. Creating a class for the enemies allowed us to have a framework for all of the enemies that were spawned, which made it significantly easier. This also allowed us to create a list of the enemies to be drawn on the game window, and connect them with the bullets that are shooting. Since both the player and the player’s bullets are unique entities (there’s only one of each), we didn’t need to use different Classes for them, rather we had functions that created them.

We also use pygame.time.Clock(). After trying out our game in the later parts of programming, we noticed that it started slowing down a bit because it had to render so many graphics. Our solution to this issue was making all entities significantly faster, while using an FPS limit for the program to run on.

The main function of the game lies within the while loops. We have different while loops for different parts of the program (menu, options, game running), because each one of those windows runs a different set of code. The menu while loop contains the users interactions with the main menu. The options while loop contains the users interactions with the mode menu. And the game running while loop contains all of the code that controls the gameplay. This includes the user input for their player control, as well as some code that controls the enemy spawning and shooting.

Player movement was glitchy in the beginning because it was originally not designed to take multiple inputs from the keyboard (Ex. if the user clicks the up arrow and the left arrow at the same time, it didn't move diagonally correctly). The player movement is defined by various if statements that relate to the key inputs from the user, which defines the direction of the velocity of the player, and therefore the direction that the player character will move. Also in creating boundaries for where the entities can move, we had to consider the size of the images that we’re using for each entity. This is why we have subtractions of numbers like 64, or 32 because these numbers are from the pixel sizes of entity images.
