In programming Outlaws, we had to start off with the basic structure of a game program, so we imported pygame and created a simple game window that accepts keyboard input.

Throughout the program, we have several saved variables, like the width, height, some colors, pictures and more that helped to make our code more clear.

At the beginning we were using enemies as similar entities to the player, but as we progressed we discovered that it was not as efficient as using pygame Sprites since there would be many enemies and they each had their own bullets. Creating a class for the enemies allowed us to have a framework for all of the enemies that were spawned, which made it significantly easier. This also allowed us to create a list of the enemies to be drawn on the game window, and connect them with the bullets that they re shooting. Since both the player and the player’s bullets are unique entities (there’s only one of each at a time), we didn’t need to use different Classes for them, rather we had functions that created them.

We also use pygame.time.Clock(). After trying out our game in the later parts of programming, we noticed that it started slowing down a bit because it had to render so many graphics. Our solution to this issue was making all entities significantly faster, while using an FPS limit for the program to run on.

The main function of the game lies within the while loops. We have different while loops for different parts of the program (menu, options, game running), because each one of those windows runs a different set of code. The menu while loop contains the users interactions with the main menu. The options while loop contains the users interactions with the mode menu. And the game running while loop contains all of the code that controls the gameplay. This includes the user input for their player control, as well as some code that controls the enemy spawning and shooting.

Within the main menu loop is the if statements that define the users interaction with the menu buttons. These interactions are defined by the coordinates of the menu button pictures and where the user clicks their mouse. The mode menu's functionality is very similar. The only difference is that we included if statements to determine the color of the buttons. This gives the user some signal as to which mode is currently selected. Also, the mode that is selected alters the spawn rate of the enemies.

As stated earlier, the game running loop contains the meat of the code. This is where the player movement is defined and the algorithms for enemy spawning and shooting. Player movement was glitchy in the beginning because it was originally not designed to take multiple inputs from the keyboard (Ex. if the user clicks the up arrow and the left arrow at the same time, it didn't move diagonally correctly). The player movement is defined by various if statements that relate to the key inputs from the user, which defines the direction of the velocity of the player, and therefore the direction that the player character will move. Also in creating boundaries for where the entities can move, we had to consider the size of the images that we’re using for each entity. This is why we have subtractions of numbers like 64, or 32 because these numbers are from the pixel sizes of entity images. The spawning of enemies is pretty simple, but is dependent on the mode that the user picks. Harder modes spawn enemies faster. The game starts out with three enemies, and more spawn based on the mode. If there are no enemies are left, three more are automatically spawned so that the player has a chance to meet the minimum required score to win. Enemy shooting is also dependent on time passed. Enemies will shoot every three seconds to simulate reload time and to allow the user to counter any shots. The necessary score to win is also determined by the mode that the player selected. In easy mode you have to shoot 15 enemies, in normal you have to shoot 20, and in hard you have to shoot 25. This is to create more difference between the modes and give added difficulty.

A final thing that we changed before finishing up our work was adding a play again button. This is why all running code is inside one gigantic while loop that only ends once you choose to quit the game (or not play again).
